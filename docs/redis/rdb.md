# Redis持久化RDB

Redis 提供了2个不同形式的持久化方式。

- RDB（Redis DataBase）
- AOF（Append Of File）

## RDB

### 概念

在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里

### 执行过程

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

### Fork意义

Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程  
在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”  
一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。  

### RDB图解

![rdb图解][1]

### 怎么配置

主要是找到启动配置文件`redis.config`,其中有几个配置项需要具体设置即可。

需要说明的是默认情况下RDB是开启的。

- 备份的文件名: dbfilename dump.rdb
- 保存位置: dir ./
- 开启RDB同时配置备份频率(save 时间 次数)
  
  - save 3600 1 代表 每隔3600秒内有1次写操作就备份一次。
  - save 30 10  代表 每隔30秒内有10次写操作就备份一次。
  - save 60 10000 代表 每隔60秒内有10000此写操作就备份一次。

- stop-writes-on-bgsave-error: 当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.
- rdbcompression: 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。
                 如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.
- rdbchecksum: 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，
                         但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能
                         推荐yes.

### 怎么主动让RDB备份
通过在redis客户端调用save和bgsave命令即可。  
- save: save时只管保存，其它不管，全部阻塞。手动保存。不建议。
- bgsave: Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。

其他说明: 
- 可以通过lastsave 命令获取最后一次成功执行快照的时间。
- 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义




### 怎么恢复文件

1. 先通过config get dir  查询rdb文件的目录 
2. 直接先把原有的dump.rdb手动复制到其他位置，以防止误操作造成持久化数据丢失。
3. 关闭redis，然后直接启动redis即可，备份数据会自动加载。

### 优点

- 适合大规模的数据恢复
- 对数据完整性和一致性要求不高更适合使用
- 节省磁盘空间
- 恢复速度快

### 缺点

- Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑
- 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。
- 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。


### 怎么关闭RDB
配置文件关闭  
在配置文件中注释掉save指令，或者给save传入空字符串，代表关闭了RDB的功能。  
然后重启redis即可。

运行中关闭  
 动态停止RDB，在连上redis后，输入命令为`redis-cli config set save ""`, 表示禁用保存策略。
  
### 总结

RDB是一个非常紧凑的文件，RDB在保存RDB文件时父进程唯一需要做的是fork出一个子进程，接下来的全部工作由子进程做，父进程不需要做任何的IO操作，所以RDB持久化方式
可以最大化使用redis的性能。同时，与AOF相比，在恢复大的的数据集的时候，会更快点。

不过，RDB存在严重的丢失文件的风险，因为是按照频率备份数据的，如果出现了服务器异常，那么最后一次的redis主进程的数据可能会丢失。
再者，数据量多的时候主进程容易阻塞，因为Redis在Fork一份具有数据等一模一样的子进程的时候，当数据量很大的时候，会很耗时，可能影响到Redis的正常响应，主要是Fork的时候数据多，造成fork时间长，主进程长时间会阻塞了。





[1]: /images/redis/rdb01.png
