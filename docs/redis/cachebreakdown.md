# 缓存击穿

### 主要原因

key对应的数据存在，但在redis中过期，比如某个很多人请求的商品，
此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，
这个时候大并发的请求可能会瞬间把后端DB压垮。

key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。
这个时候，需要考虑一个问题：缓存被“击穿”的问题。

## 图解

![缓存击穿][2]

## 解决方案

### 预先设置热门数据

在redis的key的高峰来之前，把一些热门的数据，提前设置到缓存中，同时过期时间设置的长一点。

### 实时监控延长过期时间

在redis实时监控，发现某些key访问很频繁，同时快过期了，那么直接延长该key的过期时间。

### 使用锁机制

1. 当请求后，发现缓存时效了，不要立刻去查数据库。
2. 使用redis命令setnx创建一个互斥锁。

因为setnx具有性质为，当有key了就不能覆盖重复设置key了。

- 如果能够成功创建一个互斥锁，那么锁住当前的操作，然后去查询数据库，查完数据库后，把数据写到缓存后，清除互斥锁。
- 如果不可以创建一个互斥锁，那么就走else分支，然后线程等待几百毫秒后，再尝试去setnx加一个锁。

![缓存击穿使用锁解决方案][2]

:::tip
这里的锁机制不够完善，一个完整的锁，需要具有原子性，同时存储解锁竞争等问题，要满足谁上锁那么就谁解锁，因此可以使用分布式锁的逻辑。
:::

## 参考分布式锁

[参考分布式锁逻辑](./distributedlock.md)

[2]: /images/redis/cache02.png
[3]: /images/redis/cache03.png
